<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>day1_solution</title>
</head>
<body>
    <script >
        //SUB hoisting
        /*use functions and variables before they're declared.
        the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, */
        // https://developer.mozilla.org/en-US/docs/Glossary/Hoisting
        //.-> varible hoisting
        console.log(var1);//undefined
        //console.log(var2);//error ReferenceError Cannot access 'var2' before initialization
        // console.log(var6);//error var6 is not defined
        var var1=20;
        let var2=30
        var var3;
        let var4;
        // const var5;
        // var6;
        console.log(var3,var4)//undefied  undefied 
        //console.log(var5,var6) //error SyntaxError (Missing initializer in const declaration) error ReferenceError(not defined)
        //.-> function hoisting
        fun1("Prajwal","Veeresh");// we wouldn't get any ERRORS 
        console.log(fun1);// fun1 holds the hole function as value
        function fun1(first,last){
             console.log(first,last);
        }
        // fun2("Prajwal","Veeresh");// error TypeError: fun2 is not a function
        console.log(fun2);//undefined
        var fun2=(first,last)=>{
          
        }
        // fun3("Prajwal","Veeresh");//// error TypeError: fun3 is not a function
        console.log(fun3);//undefined
        var fun3=function(first,last){

        }
        //console.log(fun4);//error ReferenceError Cannot access 'fun4' before initialization
        let fun4=function(first,last){

        }
        //SUB TDZ temporal dead zone
        /*there is a period between entering scope and being declared where they cannot be accessed. This period is the temporal dead zone (TDZ).
        Accessing let and const varibles  in the inner scope still causes a ReferenceError. If let were not hoisted, it would log outer value.
        
        The TDZ is a good thing because it helps to highlight bugs—accessing a value before it has been declared is rarely intentional.
        */
         
        /*https://www.freecodecamp.org/news/what-is-the-temporal-dead-zone/
          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
          https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone
        */
        //
        {
        // This is the temporal dead zone for the age variable!
        // This is the temporal dead zone for the age variable!
        // This is the temporal dead zone for the age variable!
        // This is the temporal dead zone for the age variable!
        let age = 25; // Whew, we got there! No more TDZ
        console.log(age);
        }
        /*The TDZ also applies to default function arguments. Arguments are evaluated left to right, and each argument is in the TDZ until it is assigned:*/
        /*function testDefaults(a = b, b) { }
        testDefaults(undefined, 1);*/

        //SUB let const var
        //.-> let v/s var
        var var7;
        //let var7;//error SyntaxError: Identifier 'var7' has already been declared
        let var8;
        //let var8;//error SyntaxError: Identifier 'var8' has already been
        // var var8; //error SyntaxError: Identifier 'var8' has already been
        var var7;// no Error
        //.-> const v/s let
        let var9=10;
        var9 =20;
        const var10=10;
        //var10=20;// error TypeError
        //SUB data types in js
        /*Data types basically specify what kind of data can be stored and manipulated within a program.
        There are 7 Primitive data types and Object, Array, and Function (which are all types of objects) are composite data types in JavaScript
        */
        //.-> primitive data types
        //1.The Boolean data type can hold only two values: true or false. 
        var isReading = true;   
        var isSleeping = false;
        console.log(typeof isReading);
        //Boolean values also come as a result of comparisons in a program. 
        var a = 2, b = 5, c = 10;
        console.log(b > a) // Output: true
        console.log(b > c) // Output: false
        /*JavaScript, there are only five falsy values.
          zero, 
          the empty string,
          undefined, 
          null,
          and not a number,*/
        //.->  Undefined type
        /*The undefined data type can only have one value-the special value undefined. If a variable has been declared, 
        but has not been assigned a value, has the value undefined.*/
        console.log(typeof var21);//undefined
        var var21;
        if(undefined===var21){
            console.log(true,21);//true
        }
        if("undefined"!==var21){
            console.log(true,21);//true
        }
        //.->null type
        /*that can have only one value-the null value. A null value means 
        that there is no value. It is not equivalent to an empty string ("") or 0, it is simply nothing.
        
        https://www.tutorialsteacher.com/javascript/javascript-null-and-undefined
        You can assign null to a variable to denote that currently that variable does not have any value 
        but it will have later on. A null means absence of a value.*/
        let var22=null;
        console.log(var22,typeof var22);//null object
        /*In the above example, null is assigned to a variable myVar. It means we have defined a variable 
        but have not assigned any value yet, so value is absence.*/
        if(var22==undefined)
         console.log(true,22);// true 22
        if(var22!==undefined)
          console.log(true,22);// true 22
        //.-> The String Data Type 
        /*JavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned 
        integer values.
        Each element in the String occupies a position in the String. The first element is at index 0, the next at 
        index 1, and so on. The length of a String is the number of elements in it.
        Strings are created using single or double quotes.

        ****JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it.****
        */
        let str="Prajwal";
        let str_1=str[0]="p";
        console.log(str,str[0],str_1);//Prajwal P p
        let str_2=str.toUpperCase();
        console.log(str,str_2)// Prajwal PRAJWAL
         //.-> number type
         /*in Js The number data type is used to represent positive or negative  or decimal place */
         var a1 = 25;         // integer
         var b2 = 80.5;       // floating-point number
         var c3 = 4.25e+6;    // exponential notation, same as 4.25e6 or 4250000
         var d4 = 4.25e-6;    // exponential notation, same as 0.00000425
         console.log(a1,b2,c3,d4);//25 80.5 4250000 0.00000425
         /*The Number data type also includes some special values which are: Infinity, -Infinity and NaN*/
         console.log(10/0,typeof Infinity);// +ve Infinity,number
         console.log(-10/0,typeof -Infinity)//-ve Infinity,number

         //.-> SUB NaN not a number
         /*NaN stands for Not a Number. It represents a value which is not a valid number.

          NaN is a property of the global object. The initial value of NaN is Not-A-Number — 
          the same as the value of Number.NaN. and typeof NaN is “number”.
          NaN is unequal to every other value in JavaScript, including itself
          
          It doesn’t make a difference if use Strict equality (===) and equality(==) for NaN.

          if you want check NaN with itself, so we can use Object.is() method,Object.is() 
          method is used to determine whether two values are the same or not. 
          
          NaN, It is a result of an invalid or an undefined mathematical operation,
          like taking example the 1.square root of -1 or 2.dividing 0 by 0, or 3.math operation b/w number and alphatical not an addition operation  etc.*/ 
          console.log("text"/10,typeof NaN);//NaN 'number'
          console.log(Math.sqrt(-1))//NaN
          console.log(0/0)//NaN
          console.log(NaN===NaN,23);//flase NaN
          console.log(Number.NaN === NaN,23); // false
          console.log(Number.isNaN(NaN),23);//true
          var fun23=(v)=> v !== v;
          console.log(fun23(1));// false
          console.log(fun23(NaN));// true
          //<- in-complete
          
          //SUB Strict equality (===) and equality(==)
          
        //SUB JavaScript is a loosely typed and dynamic language 
        /*means we don’t have to explicitly specify types of variables and objects. but in A strongly typed language we should 
        specified what kind of data/value we are storing it
        but TypeScript is a superset of JavaScript it is strongly typed language*/
        let foo = 42;    // foo is now a number
        foo     = 'bar'; // foo is now a string
        foo     = true;  // foo is now a boolean

        //SUB difference between type conversion and type coercion/ 
        // https://betterprogramming.pub/implicit-and-explicit-coercion-in-javascript-b23d0cb1a750
        //.-> coercion or implicit  type conversion 
         /*Type coercion is the automatic or implicit conversion of values from one data type to another 
         such as strings to numbers). is a implicit  type conversion */
         let var32=88;
         let str3="10";
         console.log(var32+str3,typeof (var32+str3));//var32 automatically converted to into string
         console.log(var32-str3,typeof (var32-str3));//str3 automatically converted to into number
         console.log(str3-5,typeof(str3-5))//5 'number'
        //.-> Explicit  type conversion in js 
        /*Type conversion is done explicitly in code using the inbuilt functions like Number(), String(), Boolean(), etc.*/
        let var33=88;
        let str4="10";
        str4=Number(str4);//explicitly converting string into number
        console.log(var33+str4,typeof (var33+str4));//98 'number'

        
        //SUB pass by value and pass by reference
        //https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language#:~:text=It's%20always%20pass%20by%20value,look%20like%20pass%20by%20reference.
        /*The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both 
        passed-by-value and passed-by-reference.

        In JavaScript, all function arguments are always passed by value. It means that JavaScript copies the values of the 
        variables into the function arguments.
        Any changes that you make to the arguments inside the function do not reflect the passing variables outside of the function.
        In other words,the changes made to the arguments are not reflected outside of the function.


        If function arguments are passed by reference, the changes of variables that we pass into
        the function will be reflected outside the function.
        (when we consider that the variable to the object holds the object itself).
        means adding one more name for the varible so it will pointing to the same varible and 
        new name dosn't take new memory location.
        In fact, when passing an object to a function, we are passing the reference of that object, not the actual 
        object. Therefore, if in  function can modify the properties of the object via its reference.
        

        */
        //.-> pass-by-value(primitive data type)
        var var41=10;
        var var42=20;
        console.log("prim before swap:",var41,var42);//10 20
        fun41(var41,var42);
        function fun41(para1,para2){
            para1=para1+para2;//10+20=30
            para2=para1-para2;//30-10=20
            para1=para1-para2;//30-20=10
            console.log("prim after swap:",para1,para2);//20 10
            console.log("prim after swap:",var41,var42);//10 20
        }
        
        /*in pass by value each varible allocating thire new memory allocation*/


        //.-> pass-by-reference (objects)
        var obj41={
          var1:10,
          var2:20
        }
        console.log("main-obj before swap:",obj41.var1,obj41.var2);//10 20
        fun42(obj41);//pass by reference
        function fun42(obj){
          obj.var1=obj.var1+obj.var2;
          obj.var2=obj.var1-obj.var2;
          obj.var1=obj.var1-obj.var2;
          console.log("refr-obj after swap:",obj.var1,obj.var2);//20 10
          console.log("main-obj after swap:",obj41.var1,obj41.var2);//20 10
        }
        /*in pass by reference adding one more name for the varible so it will pointing to the same varible and 
        new name dosn't take new memory location
        In fact, when passing an object to a function, we are passing the reference of that object, not the actual 
        object. Therefore, the function can modify the properties of the object via its reference.
        */
        //.-> pass-by-value (objects)
        //1..->  actual pass-by-reference
        /*if you actually change the value of the object variable you will see that 
         the change does not persist, proving it's really pass by value.*/
         var obj43={
          var1:10,
          var2:20
         };
         console.log("obj3 before swap:",obj43.var1, obj43.var2);//10 20
         fun44(obj43);
         function fun44(obj){
          obj={var1:20,var2:10};
          console.log("sub-obj3 after swap:",obj.var1, obj.var2);//20 10
          console.log("obj3 after swap:",obj43.var1, obj43.var2);//10 20
         }

        //2..-> actual passing by value
        var obj42={
          var1:10,
          var2:20
        }
        console.log("obj2 before swap:",obj42.var1, obj42.var2);//10 20
        fun43(obj42.var1, obj42.var2);// pass-by-value even object
        function fun43(para1,para2){
            para1=para1+para2;//10+20=30
            para2=para1-para2;//30-10=20
            para1=para1-para2;//30-20=10
            console.log("prim after swap:",para1,para2);//20 10
            console.log("obj2 after swap:",obj42.var1, obj42.var2);//10 20
        } 

        //SUB deep and shallow copies
        //https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/
        //Primitive data types
        /*tightly coupled with the variable they are assigned to. They only exist once. That means you 
        do not really have to worry about copying primitive data types in JavaScript.*/
        var var5="Prajwal V";
        let var51=var5;
        var51="Veeresh";
        console.log(var5,var51);//Prajwal V Veeresh

        //Composite data types — Objects and Arrays
        /*These values are actually stored just once when instantiated, and assigning a variable 
        just creates a pointer (reference) to that value.*/
        //.-> shallow copy like(by refrence/adr)
        /*A shallow copy means that certain (sub-)values are still connected to the original variable.*/
        var obj6={
          name:"Prajwal",
          from:'Bengaluru',
          phoneNo:636200000000
        }
        var new_obj6=obj6;
        new_obj6.from="Mysore";
        console.log(obj6.from,new_obj6.from);//Mysore Mysore

        /*There are multiple ways to make copies of objects in deep copy
          1.Spread operator
          2.*/
        //.-> deep copy  like(by value)
        /*A deep copy means that all of the values of the new variable are copied and disconnected from the original variable. */
        //1.Spread operator
        var new_obj7={...obj6};
        new_obj7.from="Chikkamangalore";
        console.log(new_obj7.from,new_obj6.from);//Chikkamangalore mysore
         

        /*Function :is a A block of code which we can use multiple times, so you define or 
        declare it once, and then  use it wherever we want as many times .*/
        //SUB IIFE immediately-invoked-function-expression
        /*Jit is a way to execute functions immediately, as soon as they are created.
        It is a designd for  Self-Executing Anonymous Function. it cannot be invoked again after execution:
  
        there is a major use cases of this
        they don’t pollute the global object
        measns  that:When we define a function, the JavaScript engine adds the function to the global object.In web browsers
        Likewise, if we declare a variable outside of a function using the var keyword, the JavaScript engine also adds 
        the variable to the global object,
        If you have many global variables and functions, the JavaScript engine will only release the memory allocated 
        for them until the global object loses its scopes.

        As a result, the script may use the memory inefficiently. On top of that, having global variables and 
        functions will likely cause the name collisions also.important to limit the number of global variables.
        
        One way to prevent the functions and variables from polluting the global object so we use immediately 
        invoked function expressions.
        
         We basically have a function defined inside parentheses, and then we append ()
         to execute that function:
        */
        (function (){
          console.log("IIFE");
        })();
        
        //SUB Higher Order Functions
        /*A higher order function is a function that takes a function as an argument, or returns a function.
        we are using higher-order functions when passing callback functions.

        we know some pre-defined methods are map,filter,settimout,Eventlistener these methods take a function as an argument. 
        They're example for higher order functions.
        */

        //SUB callback functions
        /*A callback function is a function passed into another function as an argument. This function is invoked inside the 
        outer function to complete an action.

        this callback function uesd in many inbuild methods:
        like,filter,map,addEventListener

        usecase of callback function
        */
        //example:
        function callBackFun(message) {
           console.log(message);
        }
        function outerFun(callback, message){
          callback(message);
        }
        outerFun(callBackFun, "Hello PreBytes");
        
        //inbuild methods for callback
        // <button type="button" class="button">click</button>
        /*let click=document.querySelector(".button");
        click.addEventListener("click",()=>{
        console.log("hello everyone");
        })*/
        let arr=[1,2,3,4,5,6,7,8,9,10];
        let eve_arr=arr.filter((a)=>a%2==0);
        
           //SUB  recurstion
         /*recurstion is a method of solving problems by breaking them  into smaller subsets of the main problem, so we can use
         this samll subset to find solustion.

         in programming we can achive this by calling a function itself, usually with a different input passed to the child function.
         It calls itself over and over until an exit condition is reached, and then passes the results back up the call stack

         if we doing with recurstion in programming we should keep two things in mind
         1.base condition 
         2.what is the return type

         there are many different way to do recurstion
         1.tail recurstion- when a recursive call is the last thing
         2.Head Recursion- when a recursive call is the first thing
         3.Tree Recursion-
         4.Indirect Recursion-
         5.Nested Recursion-
         */
         //examples 1.find out Factorial of number 2.find Sum of Natural Number 3.exponet function means M^n  
         function factorial(n){
           if(n===1){
             return 1;
           }
           else{
             return n*factorial(n-1);// tail Recursion
           }
         }
         console.log(factorial(5));
     

        //SUB this keyword
        /*every "function execution context(FEC) has three components:
           1.variable environment
           2.Scope chain
           3.this keyword 
        this keyword  is Special variable that is created for every execution context (every function). 
        Takes the value of (say points to) the “owner” of the function in which the this keyword is used
        this is NOT static. It depends on how the function is called, and its value is only assigned
        when the function is actually called. 
        
        example
        1.Simple function call (simple function call method not attached to any object) in this case this keword refer to window object in browser
        and global object in node-js
        2.function attached to an object, in this case this keyword' points to parent object of fucntion
        3.but in arrow functions do not get their own 'this keyword' (lexical this keyword,)
           because it simply gets picked up from the outer lexical scope of the arrow function.
           basically an arrow function inherits the this keyword from the parent scope.*/
        console.log(`in global execution context 'this keyword' points to window object: `,this);
        //SUB function attached to an object
        var obj={
            firstName:"Prajwal",
            lastName:"Veeresh",
            method:function(){
                console.log(`in function execution context 'this keyword' points to parent object of method: `,this);
                console.log(`fullName: ${this.firstName} ${this.lastName}`);
            }
        }
        obj.method();
        //SUB arrow function
        /* arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations.
          Limitations when we use arrow function expression:
           1.functions do not get their own 'this keyword' basically an arrow function inherits the this keyword from the parent scope.
           2.Can not be used as constructors.
           3.Not suitable for call, apply and bind methods, which generally rely on establishing a scope. 
            */

        //SUB Simple function call (method not attached to any object)
        function fun(){
            console.log(`in function execution context 'this keyword' points to parent object of method: `,this);
            //O/P window object
        }
        fun();

        /*SUB arrow function arrow functions do not get their own 'this keyword' (lexical this keyword,)
           because it simply gets picked up from the outer lexical scope of the arrow function.*/
        var obj2={
            from:"Bangalore",
            method:()=>{
                console.log(this);// O/P window object
            }
        }
        obj2.method();
        var obj3={
            to:'USA',
            inside_obj:{
                flightNo:145678,
                inside_method:()=>{
                    console.log(this);// O/P window object
                }
            }
        }
        obj3.inside_obj.inside_method();
        
        // .-> basically an arrow function inherits the this keyword from the parent scope.
        var obj4={
            address:"vidyaranayapura Banlaore",
            ag:24,
            method:function(){
                console.log(this);
                var nested_method=()=>{
                    console.log("nested arrow method: ",this); // O/P obj4 object 
                }
                nested_method();
                function nested_method2(){
                    console.log("nested declration method: ",this);// O/P window object
                }
                nested_method2();
            }
        }
        obj4.method();
      
        //SUB call,bind,apply
        /*Javascript provides wide variety of inbuilt methods to help in achieving reusable code.
          call, apply, and bind are few of such methods in JavaScript to achieving resuable code
          
          that allow a single function to be used on multiple objects.

          example we have two objects and inside that with same methods
           */
          let prepBytes1={
            name:'Elevation Academy ',
            course:'Full Stack Web Development Programs',
            // display:function(){
            //   console.log(`${this.name} for ${this.course}`);
            // }

          }
         let prepBytes2={
          name:'ZENITH',
          course:'Personalised Coding Programs',
          // display:function(){
          //     console.log(`${this.name} for ${this.course}`);
          //   }
         }
        //  prepBytes1.display();
        //  prepBytes2.display();
        /*.-> 1.usecase instead of adding display property in both prepBytes1 and prepBytes2, we can just add
         it in prepBytes1 and borrow it for prepBytes2.

         We are invoking display method for prepBytes2 by borrowing that method from prepBytes1 by using call keyword.

         Here this keyword inside display method refers to the current object from which it gets invoked. That’s 
         why when we pass prepBytes2 object as first argument in call method, this.name and this.course refers to name and 
         course properties of prepBytes2 object.*/
        //  prepBytes1.display.call(prepBytes2);
         
         /*.-> 2.usecase declear display function as independent function */
        //  let display=function (){
        //   console.log(`${this.name} for ${this.course}`);
        //  }
        //  display.call(prepBytes1);
        //  display.call(prepBytes2);

        //.-> 3.usecase if We have add  new arguments to the display function, 
        /*call: We can pass further comma separated arguments to call method
          1st argument to call method should always be the object from which are accessing the values. And after 
          that we can pass any number of arguments which gets directly accessible by display function

          apply: but in apply method does the exact same job as call method, we pass arguments in the form of array.  */
          let display=function(no_student,no_getJoj){
            console.log(`${this.name} for ${this.course}, ${no_student} students have done this course & ${no_getJoj} students got job`);
          }
          display.call(prepBytes1,"*****","#####");
          display.apply(prepBytes2,["****","####"]);
          //call and apply methods are immediately calling method 

          /*bind:it is same as call method but bind method binds the  method with object and returns the copy of that method.
          we are storing the return method in a variable and we can invoke it later*/
          let bindr=display.bind(prepBytes2,"^^^^^","*****");
          bindr();
          
          //SUB lexical scope
          /*A lexical scope in JavaScript means that a variable defined outside a function can be accessible inside 
          inside function defined after the variable declaration. But the opposite is not true*/
          /*var a = 10; // variable a assigned to 10
          var par_func = function (){ // outermost function
            var b = 20;
            console.log("a and b is accessible (outer):", a, b);
            var innerFunc= function (){ // innermost function
              var c = 30;
              console.log("a and b and c is accessible (innner):", a, b, c);
            }
            innerFunc();
          }
          par_func();*/


        //SUB Closures 
        /*A closure is the combination of a function and the lexical environment 
         which measn that function was declared. 
        an inner function can access to the outer function’s variables.

        The closure has three scope chains
          1.Own scope where variables defined between its curly brackets
          2.Outer function’s variables
          3.Global variables
        */ 
        var a = 10; // variable a assigned to 10
        var par_func = function (){ // outermost function
          var b = 20;
          console.log("a and b is accessible (outer):", a, b);
          var innerFunc= function (){ // innermost function
            var c = 30;
            console.log("a and b and c is accessible (innner):", a, b, c);
           }
           return innerFunc;
        }
        var var25= par_func();
        var25();
        
        //SUB scopes
        /*
         Scope: in JavaScript defines accessibility of variables, objects and functions.
         There are two types of scope in JavaScript.
          1.Global scope: Variables declared outside of any function become global variables.
            so we can be access and modified from any function.
          2.Local scope :
            a.Block Scope, it will apply only for let and const varibles but doesn't apply var varible
            b.Functional Scope, it will apply for let const and var
         
         scope-chain:the JavaScript engine will try to find the variable’s value in the current scope. 
         If it could not find the variable, it will look into the outer scope and will continue to do
         so until it finds the variable or reaches global scope.

         If it’s still could not find the variable, it will either implicitly declare the variable 
         in the global scope (if not in strict mode) or return an error.
        */
         //SUB ways of create object in JavaScript
       /*there are 5 ways to create object in js
         1.Object Literal
         2.using new Object() method 
         3.using Object.create(proto,propertiesObject)
         4.uinsg Constructor Function
         5.using ES6 Classes */


       //.-> Object Literal Way
       /*The Simplest and easiest way to create an object is using Object Literal “{}”. Just define properties and values
       inside curly braces */
       let obj51={name:"Prajwal"};
        console.log(obj51.name);
        //.-> new Object() Way
        /*way to create an Object is by using new Object().
         For simplicity, readability and execution speed, use object literal way.*/
        let obj52=new Object({name:"Prajwal"});
        console.log(obj52.name);
        //.-> Object.create(proto,propertiesObject) Way
        /*this method creates a new object, using an existing object as the prototype of the newly created object.
        it takes two parameters. The first parameter is a mandatory object that serves as the prototype of the new
        object to be created. The second parameter is an optional object which contains the properties to be added
        to the new object .*/
        let object53=Object.create(obj51,{new_property:{value:23}});//<- in completed
        console.log(object53);
        //.-> Constructor Function Way
        /*The constructor function is a function allows to create multiple objects of the same constructor function with the help
        of new keyword
        Technically speaking, a constructor function is a regular function with the following convention:
           * The name of a constructor function starts with a capital letter like Person, Document, etc.
           * A constructor function should be called only with the new operator.*/
        function Constructor_fun(name,age,phone){
            this.name=name;
            this.age=age;
            this.phone=phone;
        }
        let obj54=new Constructor_fun("Prajwal");
        console.log(obj54);
        obj54.age=23;
        console.log(obj54);
        //SUB ES6 Classes 
        /*By using classes we can create a new objects.The constructor method is a special method of a class for creating and 
        initializing an object instance of that class.
        constructor(argument0, argument1, ... , argumentN) { //////// } */
        class cls_Obj{
          constructor(name, age, phone){
            this.name=name;
            this.age=age;
            this.phone=phone;
          }
        }
        let obj55=new cls_Obj("Prajwal",23);
        console.log(obj55);
        obj55.phone='656345***';
        console.log(obj55);
        //.-> Object.assign() //<- in completed

        
        //SUB Prototypes
        /*Prototypes: are the mechanism by which JavaScript objects inherit features from one another.
        Every object in JavaScript has a built-in property called prototype.The prototype is itself an object.
        
        When we try to access a property of an object: if the property can't be found in the object itself, the prototype 
        is searched for the property. If the property still can't be found, then the prototype's prototype is searched, 
        and so on until either the property is found, or the end of the chain is reached, in which case undefined is returned.
        */
        const obj8={
          city:"Bangalore",
          greet:function (){
            console.log(`Greetings from ${this.city}`);
          }
        }
        obj8.greet();3
        console.log(obj8)//list of all the properties available to this object.
        /*these extra properties come from prototype*/
        console.log(obj8.hasOwnProperty('city'));//true
        console.log(obj8.hasOwnProperty('name'));//true
        /*Object.prototype, is the most basic prototype, that all objects have by default. The prototype of 
        Object.prototype is null, so it's at the end of the prototype chain:*/
        console.log(Object.getPrototypeOf(obj8));//Object {...}
        console.log(Object.getPrototypeOf(Object.getPrototypeOf(obj8)));//null

        //.-> Shadowing properties
        const myDate = new Date();
        console.log(myDate);
        console.log(myDate.getDate());//today date

        myDate.getDate = function() {
        console.log("Shadowing properties");
        };
        myDate.getDate();
        let arr=[10,20,30];
        function fun(){};
        let mapr=new Map();
        let setr=new Set();
        console.log(arr);


        //.-> create prototype
        // Using Object.create
        let person_obj={
          name:"Veeresh",
          college:"B.M.S.C.E"
        }
        console.log(person_obj);
        let person_obj2=Object.create(person_obj,{age:{value:"23"}});
        console.log(person_obj2);
        console.log(person_obj2.hasOwnProperty('age'));//true
        console.log(person_obj2.hasOwnProperty('name'));//false
        let person_obj3=Object.create(person_obj2,{number:{value:"9148302***"}});
        console.log(person_obj3);

        console.log(person_obj3.__proto__.__proto__.__proto__);
        console.log(Object.prototype);//Object.prototype is the most basic prototype
        console.log(person_obj3.__proto__.__proto__.__proto__.__proto__);
        console.log(Object.prototype.__proto__);
        
        //using constructor
        function Person_construct(name,from){
          this.name=name;
          this.from=from;
        }
        let person1=new Person_construct("Prajwal","Bengaluru");
        console.log(person1);
        person1.phone='636286*****';
        console.log(person1);
        Person_construct.prototype.display=function(){//property method
          console.log(`${this.name} from ${this.from}`);
        }
        Person_construct.prototype.age='18';//property value
        console.log(person1.hasOwnProperty("name"));//true
        console.log(person1.hasOwnProperty("display"));//false
        console.log(Person_construct.prototype);
        console.log(Person_construct.prototype.__proto__);
        console.log(Person_construct.prototype.__proto__.__proto__);

         //SUB DOM 
        /*The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs 
        can change the document structure, style, and content.

        The DOM represents the document as nodes and objects; that way, programming languages can interact with the page.

        A web page is a document that can be either displayed in the browser window or as the HTML source. In both cases,
        it is the same document,but Document Object Model (DOM) representation allows it to be manipulated. As an object-oriented
        representation of the web page, it can be modified with a scripting language such as JavaScript,pyton, php,ruby,bash 
        
       //SUB rest parameter and spread operator
        /*spread operator:allows you to spread out elements of an iterable object such as an array,a  map, or a set.
         (The spread operator unpacks elements.)
         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax 

         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters 
         rest parameter:allows a function to accept an indefinite number of arguments as an array (The rest parameter packs elements into an array.)
          The difference between rest parameters and the arguments object
            1.The arguments object is not a real array, while rest parameters are Array instances, meaning methods like sort, map, 
            forEach or pop can be applied on it directly
            2.The ...restParam bundles all the  parameters into a single array so we wouldn't define many paraments */
        //spread operator usecases
        //.-> literal
          //1.use case1 (array literal) when concat two or more arrys into a single array
          let arr1=[1,2,3,4,5,6,7];
          let arr2=[11,12,13,14,15,16,17];
          let arr3;
          // arr3=[arr1,arr2];//[Array(7), Array(7)]
          // arr3=[...arr1,...arr2];//1,2,3,4,5,6,7,11,12,13,14,15,16,17
          console.log(arr3);
          //2. Spread in object literals
          let obj1={name:"prajwal",age:23};
          let obj2={from:"bengaluru",concatNo:"63628****"};
          let obj3;
          //obj3={obj1,obj2};//{obj1: {…}, obj2: {…}}
          obj3={...obj1,...obj2};//{name: 'prajwal', age: 23, from: 'bengaluru', concatNo: '63628****'}
          console.log(obj3);
        //.-> use case2 if we want only first two elemnts of array to do something example
        function fun(a,b,c){
          console.log(a,b+c);// here a takes null value and b,c takes first and second elements of array respectively
        }
        let arr0=[1,2,3,4,5,6,7];
        fun(null,...arr0);
        //rest parameter usecases
        //.-> 
        function fun2(...para){// rest parameter
          console.log(para);
        }
        fun2(...arr0);//spread operator
        //.-> 
        function fun3(...para){
          console.log(para.length);
        }
        fun3(1,2,3,4,5);//5
        fun3();//0
        fun3(10,20);//2

        
         //SUB promise
        /*promise is an object  that may produce a single value some time in the future with either a resolved value or a 
        reason that it’s not resolved(for example, network error). 
        It will be in one of the 3 possible states: 
        pending:initial state, neither fulfilled nor rejected.
        fulfilled: meaning that the operation was completed successfully.
        or rejected:meaning that the operation failed.
        
        A pending promise can either be fulfilled with a value or rejected with a reason (error)

        Promises are used to handle asynchronous operations. They provide an alternative approach for callbacks by reducing 
        the callback hell and writing the cleaner code.
        
        Creating a promise:create a promise in JavaScript, you use the Promise constructor:
        */
        /*let complete=true;
        let my_promise=new Promise((resolve,reject)=>{
          if(complete){
            resolve("operation was completed successfully");
          }
          else{
            reject("operation was rejected");
          }
        })*/
        /*The Promise constructor accepts a function as an argument(callback functon) This function is called the executor,
         this executor takes two arguments as callback functions 1.resolve,2.reject

         When you call the new Promise(executor), the executor is called automatically. 
         Inside the executor, you manually call the resolve() function if the executor is completed successfully and 
         invoke the reject() function in case of an error occurs.*/

        // To see the pending state of the promise, we wrap the code of the executor in the setTimeout() function
        /*complete = false;
        let my_promise2 = new Promise((resolve, reject) =>{
          setTimeout(()=>{
              if(complete){
                resolve("operation was completed successfully");
                console.log(my_promise2);//PromiseState is fulfilled,PromiseResult is "operation was completed successfully"
              }
              else{
                reject("operation was rejected");
                console.log(my_promise2);//PromiseState is rejected, PromiseResult is "operation was rejected"
              }
          },3*1000);
        })
        console.log(my_promise2);//PromiseState is pending, PromiseResult is "undefined" */
        /*processes steps
        1.promise starts with the pending state with the value is undefined. The promise value will be 
        returned later once the promise is completed
        2.After about 3 seconds, the state of the promise becomesresolved and the promise value is the string that we passed 
        to the resolve() function.
        3.So calling the resolve() function moves the promise object to the fulfilled state.
        4.In other words, calling the reject() method moves the promise object to the rejected state. 
        and error message and the state of the promise becomes rejected after 3 seconds

        Once the promise reaches either fulfilled state or rejected state, it stays in that state and can’t switch.
        */
       //SUB Consuming a Promise 
       /*by using then, catch, finally methods to further action with a promise that becomes settled.
         then():method is used to schedule a callback to be executed when the promise is successfully resolved.
         this method takes two callback functions:- promiseObject.then(onFulfilled, onRejected);
         catch():
       */
       /*my_promise2.then((message) =>{
        console.log(message);
       }).catch((message)=>{
        console.log(message);
       })*/


       //SUB promise chaining 
       /*The instance method of the Promise object such as then(), catch(), or finally() returns a separate "promise object".
       Therefore, you can call the promise’s instance method on the return Promise. The successively calling methods in this 
       way is referred to as the promise chaining.

       The process of executing a sequence of asynchronous tasks one after another using promises is known as Promise chaining.*/
       
       //.-> whithout asynchronous dealy in promise Multiple handlers for a promise
       let my_promise3=new Promise((resolve, reject)=>{
          setTimeout(()=>{
             resolve(1);
          },1*1000)
       })
       my_promise3.then((result)=>{
         console.log(result);
         return result*2
       }).then((result)=>{
        console.log(result);
        return result*3
       }).then((result)=>{
        console.log(result);
       })
       //.-> with asynchronous dealy in promise Multiple handlers for a promise (Returning a Promise)
       let my_promise4=new Promise((resolve, reject)=>{
        setTimeout(()=>{
             resolve(1);
          },2*1000)
       })

       my_promise4.then((result)=>{
         console.log(`this exicuted after ${result} seconds of page open`);
         return new Promise((resolve, reject)=>{
          setTimeout(()=>{
             resolve(result+2);
          },2*1000)
         })
       }).then((result)=>{
        console.log(`this exicuted after ${result} seconds of page open`);
         return new Promise((resolve, reject)=>{
          setTimeout(()=>{
             resolve(result+2);
          },2*1000)
         })
       }).then((result)=>{
        console.log(`this exicuted after ${result} seconds of page open`);
       })
       
       //SUB Object Destructuring
        /* OavaScript Object Destructuring is the syntax for extracting values from an object property and assigning them 
        to a variable.
        */
        let person={
            name:"Prajwal V",
            // age:23,
            from:"Bengaluru"
        }
        /*let name=person.name;
        let age=person.age;
        let from=person.from;*/
        /*We have to explicitly mention the name and age property with the user object in dot(.) notation, then declare 
        variables accordingly and assign them. */
        // let{name,age,from}=person;

        //Setting default values and also we assign the age property to the age variable with the default value of 18.
        let{name,age:currentAge=18,from,contactNo='63628***',}=person;
        // if property not there in object it will take defult value in this case age property not there so it takes defult value as 18
        console.log(name,currentAge,from,contactNo);
    </script>
</body>
</html>
